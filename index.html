<html>
<head>
	<title>Sineyyak</title>
	<link rel="icon" type="image/x-icon" href="https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/microsoft/310/eggplant_1f346.png">
	<style>
	body {
		display: flex;
		overflow: hidden;
		align-items: center;
		background-color: #444;
		flex-direction: column;
		justify-content: center;
	}

	#canvas {
		margin-top: 0 auto;
		box-shadow: black 5px 5px 15px;
	}

	#score {
		top: 0;
		color: #ccc;
		display: flex;
		font-size: 32px;
		margin-top: 16px;
		align-items: center;
		font-family: "Impact";
		justify-content: center;
	}
	</style>
</head>

<body>
	<canvas id="canvas" width="512" height="512"></canvas>
	<p id="score"></p>
	<script defer>
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

	const cfg = {
		bgColor  : "#202020",
		headColor: "#5eba7d",
		tailColor: "#4f805c",
		foodColor: "#c25928",
		gridCount: 20,
		speed: 15
	}

	const gridCount = cfg.gridCount;
	const gridSize = canvas.width / gridCount;

	const generateRandomPos = () => { return {
		x: Math.floor(Math.random() * gridCount),
		y: Math.floor(Math.random() * gridCount)
	}};

	const foodImg = new Image();
	const eatSfx = new Audio();

	const headPos = generateRandomPos();
	const foodPos = generateRandomPos();

	const tails = [];
	let tailLength = 2;

	let score = 0;
	let gameOver = false;

	let lastRenderTime = 0;
	let inputDirection = { x: 0, y: 0 };
	let lastInputDirection = inputDirection;
	let lastEatPos = { x: null, y: null };
	let animState = 2;

	let isAnimReady = false;

	function init() {
		foodImg.src = "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/microsoft/310/eggplant_1f346.png";
		eatSfx.src = "https://freesound.org/data/previews/270/270343_5123851-lq.mp3";

		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0;
		ctx.shadowColor = "black";

		displayScore();
		window.requestAnimationFrame(main);
	}

	function main(currentTime) {
		if(gameOver) return endGame();

		window.requestAnimationFrame(main);

		const secondsPassed = (currentTime - lastRenderTime) / 1000;
		if(secondsPassed < 1 / cfg.speed) return;
		lastRenderTime = currentTime;

		updateSnakePos();
		checkFoodCollision();
		clearScreen();
		animateEat();
		drawSnake();
		drawFood();

	}

	function clearScreen() {
		ctx.fillStyle = cfg.bgColor;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	function displayScore() {
		const scoreElement = document.getElementById("score");
		scoreElement.innerHTML = score.toLocaleString();
	}

	function updateSnakePos() {
		inputDirection = getInput() || inputDirection;
		headPos.x += inputDirection.x;
		headPos.y += inputDirection.y;

		if(headPos.x >= gridCount) headPos.x = 0;
		if(headPos.y >= gridCount) headPos.y = 0;
		if(headPos.x < 0) headPos.x = gridCount - 1;
		if(headPos.y < 0) headPos.y = gridCount - 1;

		if(checkTailCollision()) gameOver = true;
	}

	function drawSnake() {
		ctx.shadowBlur = 2;
		ctx.fillStyle = cfg.tailColor;
		for(let i = 0; i < tails.length; i++) {
			ctx.fillRect(tails[i].x * gridSize, tails[i].y * gridSize, gridSize, gridSize);
		}

		tails.push({ x: headPos.x, y: headPos.y });
		if(tails.length > tailLength) tails.shift();

		ctx.shadowBlur = 0;
		ctx.fillStyle = cfg.headColor;
		ctx.fillRect((headPos.x * gridSize), (headPos.y * gridSize), gridSize, gridSize);
	}

	function isOnSnake(pos) {
		return (
			(headPos.x == pos.x && headPos.y == pos.y) ||
			tails.some(part => part.x == pos.x && part.y == pos.y)
		);
	}

	function checkTailCollision() {
		if(inputDirection.x == 0 && inputDirection.y == 0) return false;
		return tails.some(part => headPos.x == part.x && headPos.y == part.y);
	}
		
	function endGame() {
		const centerW = canvas.width/2;
		const centerH = canvas.height/2;

		ctx.textAlign = "center";

		ctx.fillStyle = "white";
		ctx.font = "38px Impact";
		ctx.strokeText("Tekrar?", centerW + 2, 262);
		ctx.strokeText("Tekrar?", centerW + 1, 261);
		ctx.fillText("Tekrar?", centerW, 260);

		ctx.font = "72px Impact";

		ctx.fillStyle = "black";
		ctx.strokeText("GEYMOVIR", centerW + 2, 202);
		ctx.strokeText("GEYMOVIR", centerW + 1, 201);
		ctx.fillText("GEYMOVIR", centerW, 200);

		ctx.fillStyle = "green";
		ctx.strokeText("Y", centerW / 2 + 2, 342);
		ctx.strokeText("Y", centerW / 2 + 1, 341);
		ctx.fillText("Y", centerW / 2, 340);

		ctx.fillStyle = "red";
		ctx.strokeText("N", canvas.width - centerW / 2 + 2, 342);
		ctx.strokeText("N", canvas.width - centerW / 2 + 1, 341);
		ctx.fillText("N", canvas.width - centerW / 2, 340);

		window.addEventListener("keydown", e => {
			if(e.key == "y") window.location.href = window.location.href;
			if(e.key == "n") window.location.href = "https://www.youtube.com/embed/5yHVzYE87nQ?autoplay=1";
		});
	}

	function drawFood() {
		ctx.shadowBlur = 20;
		ctx.drawImage(foodImg, foodPos.x * gridSize, foodPos.y * gridSize, gridSize, gridSize);
		ctx.shadowBlur = 0;
	}

	function checkFoodCollision() {
		if(headPos.x == foodPos.x && headPos.y == foodPos.y) {
			isAnimReady = true;
			lastEatPos.x = foodPos.x;
			lastEatPos.y = foodPos.y;
			eatSfx.play();
			updateFoodPos();
			tailLength++;
			cfg.speed += cfg.speed >= 60 ? 0 : 0.25;
			score++;
			displayScore();
		}
	}

	function animateEat() {
		if(!isAnimReady || !animState) return;
		const pos = lastEatPos;
		const rectSize = gridSize / 2;
		const rectCenter = gridSize / 2 - rectSize / 2;

		if(animState == 2) {
			ctx.fillStyle = "#71689888";
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, pos.y * gridSize + rectCenter, rectSize, rectSize); //left
			ctx.fillRect(pos.x * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //up
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, pos.y * gridSize + rectCenter, rectSize, rectSize); //right
			ctx.fillRect(pos.x * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //down
			return animState = 1;

		} else if(animState == 1) {
			ctx.fillStyle = "#71689833";
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //upper left
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //upper right
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //bottom right
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //bottom left
			isAnimReady = false;
			animState = 2
		}
	}

	function updateFoodPos() {
		while(isOnSnake(foodPos)) {
			foodPos.x = Math.floor(Math.random() * gridCount);
			foodPos.y = Math.floor(Math.random() * gridCount);
		}
	}

	function getInput() {
		window.addEventListener("keydown", e => {
			switch (e.key) {
				case "ArrowLeft":
				case "a":
					if(lastInputDirection.x != 0) return;
					inputDirection = { x: -1, y: 0 };
					break;
				case "ArrowUp":
				case "w":
					if(lastInputDirection.y != 0) return;
					inputDirection = { x: 0, y: -1 };
					break;
				case "ArrowRight":
				case "d":
					if(lastInputDirection.x != 0) return;
					inputDirection = { x: 1, y: 0 };
					break;
				case "ArrowDown":
				case "s":
					if(lastInputDirection.y != 0) return;
					inputDirection = { x: 0, y: 1 };
					break;
			}
		});

		lastInputDirection = inputDirection;
		return inputDirection;
	}

	window.onload = init;
	</script>
</body>

</html>
