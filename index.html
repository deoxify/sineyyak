<html>

<head>
	<title>Sineyyak</title>
	<link rel="icon" type="image/x-icon" href="https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/microsoft/310/eggplant_1f346.png">
	<style>
	body {
		display: flex;
		overflow: hidden;
		align-items: center;
		background-color: #444;
		flex-direction: column;
		justify-content: center;
	}

	#canvas {
		margin-top: 0 auto;
		box-shadow: black 5px 5px 15px;
	}
	</style>
</head>

<body>
	<!-- <canvas id="canvas" width="512" height="512"></canvas> -->
	<canvas id="canvas"></canvas>
	<script defer>
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");
	canvas.width = window.innerHeight - window.innerHeight / 20;
	canvas.height = canvas.width;

	const cfg = {
		bgColor  : "#202020",
		headColor: "#5eba7d",
		tailColor: "#4f805c",
		foodColor: "#c25928",
		gridCount: 20,
		speed: 15
	}

	const gridCount = cfg.gridCount;
	const gridSize = canvas.width / gridCount;

	const generateRandomPos = () => { return {
		x: Math.floor(Math.random() * gridCount),
		y: Math.floor(Math.random() * gridCount)
	}};

	const foodImg = new Image();
	const eatSfx = new Audio();

	const headPos = generateRandomPos();
	const foodPos = generateRandomPos();

	const tails = [];
	let tailLength = 5;

	let score = 0;
	let gameOver = false;

	let lastRenderTime = 0;
	let inputDirection = { x: 0, y: 0 };
	let lastInputDirection = inputDirection;
	let lastEatPos = { x: null, y: null };
	let animState = 2;

	let isAnimReady = false;

	function init() {
		foodImg.src = "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/microsoft/310/eggplant_1f346.png";
		eatSfx.src = "https://freesound.org/data/previews/270/270343_5123851-lq.mp3";

		ctx.textAlign = "center";
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0;
		ctx.shadowColor = "black";

		window.requestAnimationFrame(main);
	}

	function main(currentTime) {
		if(gameOver) return endGame();

		window.requestAnimationFrame(main);

		const secondsPassed = (currentTime - lastRenderTime) / 1000;
		if(secondsPassed < 1 / cfg.speed) return;
		lastRenderTime = currentTime;

		updateSnakePos();
		checkFoodCollision();
		clearScreen();
		animateEat();
		displayScore();
		drawSnake();
		drawFood();

	}

	function clearScreen() {
		ctx.fillStyle = cfg.bgColor;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	function displayScore(state = "normal") {
		const fontSize = canvas.height / 3;
		ctx.shadowBlur = 5;
		ctx.fillStyle = state == "end" ? "#ffffffa0" : "#ffffff10";
		ctx.font = String(fontSize) + "px Impact";
		ctx.fillText(score, canvas.width / 2, canvas.height - fontSize / 4);
		ctx.shadowBlur = 0;
	}

	function updateSnakePos() {
		inputDirection = getInput() || inputDirection;
		headPos.x += inputDirection.x;
		headPos.y += inputDirection.y;

		if(headPos.x >= gridCount) headPos.x = 0;
		if(headPos.y >= gridCount) headPos.y = 0;
		if(headPos.x < 0) headPos.x = gridCount - 1;
		if(headPos.y < 0) headPos.y = gridCount - 1;

		if(checkTailCollision()) gameOver = true;
	}

	function drawSnake() {
		ctx.shadowBlur = 2;
		ctx.fillStyle = cfg.tailColor;
		for(let i = 0; i < tails.length; i++) {
			ctx.fillRect(tails[i].x * gridSize, tails[i].y * gridSize, gridSize, gridSize);
		}

		tails.push({ x: headPos.x, y: headPos.y });
		if(tails.length > tailLength) tails.shift();

		ctx.shadowBlur = 0;
		ctx.fillStyle = cfg.headColor;
		ctx.fillRect((headPos.x * gridSize), (headPos.y * gridSize), gridSize, gridSize);
	}

	function isOnSnake(pos) {
		return (
			(headPos.x == pos.x && headPos.y == pos.y) ||
			tails.some(part => part.x == pos.x && part.y == pos.y)
		);
	}

	function checkTailCollision() {
		if(inputDirection.x == 0 && inputDirection.y == 0) return false;
		return tails.some(part => headPos.x == part.x && headPos.y == part.y);
	}

	function drawTextWithShadow(text, color, font, thickness, x, y){
		ctx.font = font;
		ctx.fillStyle = color;

		ctx.strokeText(text, x - 0.5, y - 0.5);

		for(let i = thickness; i > 0; i--){
			ctx.strokeText(text, x + i, y + i / 2);
		}

		ctx.fillText(text, x, y);
	}
		
	function endGame() {
		const centerW = canvas.width/2;
		const centerH = canvas.height/2;

		ctx.fillStyle = "#151515cc"
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		displayScore("end");

		drawTextWithShadow("GEYMOVIR", "orange", "72px Impact", 5, centerW, centerH / 2 + 36);
		drawTextWithShadow("Tekrar ??", "white", "38px Impact", 5, centerW, centerH + 19);
		drawTextWithShadow("Y", "green", "72px Impact", 5, centerW / 2, centerH + centerH / 2 + 36);
		drawTextWithShadow("N", "red", "72px Impact", 5, canvas.width - centerW / 2, canvas.height - centerH / 2 + 36);

		window.addEventListener("keydown", e => {
			if(e.key == "y") window.location.href = window.location.href;
			if(e.key == "n") window.location.href = "https://www.youtube.com/embed/5yHVzYE87nQ?autoplay=1";
		});
	}

	function drawFood() {
		ctx.shadowBlur = 10;
		ctx.drawImage(foodImg, foodPos.x * gridSize, foodPos.y * gridSize, gridSize, gridSize);
		ctx.shadowBlur = 0;
	}

	function checkFoodCollision() {
		if(headPos.x == foodPos.x && headPos.y == foodPos.y) {
			isAnimReady = true;
			lastEatPos.x = foodPos.x;
			lastEatPos.y = foodPos.y;
			eatSfx.play();
			updateFoodPos();
			tailLength++;
			cfg.speed += cfg.speed >= 60 ? 0 : 0.25;
			score++;
		}
	}

	function animateEat() {
		if(!isAnimReady || !animState) return;
		const pos = lastEatPos;
		const rectSize = gridSize / 2;
		const rectCenter = gridSize / 2 - rectSize / 2;

		if(animState == 2) {
			ctx.fillStyle = "#71689888";
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, pos.y * gridSize + rectCenter, rectSize, rectSize); //left
			ctx.fillRect(pos.x * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //up
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, pos.y * gridSize + rectCenter, rectSize, rectSize); //right
			ctx.fillRect(pos.x * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //down
			return animState = 1;

		} else if(animState == 1) {
			ctx.fillStyle = "#71689833";
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //upper left
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, (pos.y - 1) * gridSize + rectCenter, rectSize, rectSize); //upper right
			ctx.fillRect((pos.x + 1) * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //bottom right
			ctx.fillRect((pos.x - 1) * gridSize + rectCenter, (pos.y + 1) * gridSize + rectCenter, rectSize, rectSize); //bottom left
			isAnimReady = false;
			animState = 2
		}
	}

	function updateFoodPos() {
		while(isOnSnake(foodPos)) {
			foodPos.x = Math.floor(Math.random() * gridCount);
			foodPos.y = Math.floor(Math.random() * gridCount);
		}
	}

	function getInput() {
		window.addEventListener("keydown", e => {
			switch (e.key) {
				case "ArrowLeft":
				case "a":
					if(lastInputDirection.x != 0) return;
					inputDirection = { x: -1, y: 0 };
					break;
				case "ArrowUp":
				case "w":
					if(lastInputDirection.y != 0) return;
					inputDirection = { x: 0, y: -1 };
					break;
				case "ArrowRight":
				case "d":
					if(lastInputDirection.x != 0) return;
					inputDirection = { x: 1, y: 0 };
					break;
				case "ArrowDown":
				case "s":
					if(lastInputDirection.y != 0) return;
					inputDirection = { x: 0, y: 1 };
					break;
			}
		});

		lastInputDirection = inputDirection;
		return inputDirection;
	}

	window.onload = init;
	</script>
</body>

</html>
